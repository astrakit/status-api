package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"sync"
	"time"
)

type HostType string

const (
	TypeHTTP HostType = "http"
	TypeTCP  HostType = "tcp"
)

type Metric struct {
	Timestamp    time.Time `json:"timestamp"`
	ResponseTime int64     `json:"response_time_ms"`
	IsUp         bool      `json:"is_up"`
}

type Host struct {
	ID           string    `json:"id"`
	Name         string    `json:"name"`
	Type         HostType  `json:"type"`
	Address      string    `json:"address"`
	Port         int       `json:"port,omitempty"`
	IsUp         bool      `json:"is_up"`
	ResponseTime int64     `json:"response_time_ms"`
	LastChecked  time.Time `json:"last_checked"`
	Metrics      []Metric  `json:"metrics,omitempty"`
}

func (h *Host) AddMetric(responseTime int64, isUp bool) {
	metric := Metric{
		Timestamp:    time.Now(),
		ResponseTime: responseTime,
		IsUp:         isUp,
	}

	h.Metrics = append(h.Metrics, metric)
	h.PruneOldMetrics()
}

func (h *Host) PruneOldMetrics() {
	cutoff := time.Now().Add(-2 * time.Hour)
	newMetrics := []Metric{}

	for _, metric := range h.Metrics {
		if metric.Timestamp.After(cutoff) {
			newMetrics = append(newMetrics, metric)
		}
	}

	h.Metrics = newMetrics
}

type StatusStore struct {
	hosts      map[string]Host
	mu         sync.RWMutex
	nextHostID int
}

func NewStatusStore() *StatusStore {
	return &StatusStore{
		hosts:      make(map[string]Host),
		nextHostID: 1,
	}
}

func (s *StatusStore) AddHost(host Host) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if host.ID == "" {
		host.ID = strconv.Itoa(s.nextHostID)
		s.nextHostID++
	}

	s.hosts[host.ID] = host
}

func (s *StatusStore) GetHost(id string) (Host, bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	host, exists := s.hosts[id]
	return host, exists
}

func (s *StatusStore) GetAllHosts() []Host {
	s.mu.RLock()
	defer s.mu.RUnlock()
	hosts := make([]Host, 0, len(s.hosts))
	for _, host := range s.hosts {
		hosts = append(hosts, host)
	}
	return hosts
}

func (s *StatusStore) RemoveHost(id string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.hosts, id)
}

func (s *StatusStore) UpdateHost(host Host) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.hosts[host.ID] = host
}

func (s *StatusStore) SaveToFile(filename string) error {
	s.mu.RLock()
	defer s.mu.RUnlock()

	hosts := s.GetAllHosts()

	hostsToSave := make([]Host, len(hosts))
	for i, host := range hosts {
		hostCopy := host
		hostCopy.Metrics = nil
		hostsToSave[i] = hostCopy
	}

	data, err := json.MarshalIndent(hostsToSave, "", "  ")
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filename, data, 0644)
}

func (s *StatusStore) SaveMetricsToFile(filename string) error {
	s.mu.RLock()
	defer s.mu.RUnlock()

	hosts := s.GetAllHosts()

	type MetricRecord struct {
		ID      string   `json:"id"`
		Metrics []Metric `json:"metrics"`
	}

	type MetricsData struct {
		Warning     string         `json:"warning"`
		GeneratedAt time.Time      `json:"generated_at"`
		Records     []MetricRecord `json:"records"`
	}

	records := make([]MetricRecord, 0, len(hosts))
	for _, host := range hosts {
		records = append(records, MetricRecord{
			ID:      host.ID,
			Metrics: host.Metrics,
		})
	}

	data := MetricsData{
		Warning:     "DO NOT EDIT THIS FILE - Automatically generated by status-api",
		GeneratedAt: time.Now(),
		Records:     records,
	}

	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filename, jsonData, 0644)
}

func (s *StatusStore) LoadFromFile(filename string) error {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		if os.IsNotExist(err) {

			return nil
		}
		return err
	}

	var hosts []Host
	if err := json.Unmarshal(data, &hosts); err != nil {
		return err
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	highestID := 0
	for _, host := range hosts {
		s.hosts[host.ID] = host

		if id, err := strconv.Atoi(host.ID); err == nil && id > highestID {
			highestID = id
		}
	}

	s.nextHostID = highestID + 1
	return nil
}

func CheckHostStatus(host Host) Host {
	startTime := time.Now()

	switch host.Type {
	case TypeHTTP:
		var urlToCheck string
		if host.Port > 0 {
			urlToCheck = fmt.Sprintf("%s:%d", host.Address, host.Port)
		} else {
			urlToCheck = host.Address
		}

		if _, err := url.Parse(urlToCheck); err == nil {
			if !hasHTTPPrefix(urlToCheck) {
				urlToCheck = "http://" + urlToCheck
			}
		}

		client := http.Client{
			Timeout: 5 * time.Second,
		}

		resp, err := client.Get(urlToCheck)
		responseTime := time.Since(startTime).Milliseconds()
		host.ResponseTime = responseTime
		host.LastChecked = time.Now()

		if err != nil {
			host.IsUp = false
		} else {
			defer resp.Body.Close()
			host.IsUp = resp.StatusCode < 400
		}

	case TypeTCP:
		var address string
		if host.Port > 0 {
			address = fmt.Sprintf("%s:%d", host.Address, host.Port)
		} else {
			address = host.Address
		}

		conn, err := net.DialTimeout("tcp", address, 5*time.Second)
		responseTime := time.Since(startTime).Milliseconds()
		host.ResponseTime = responseTime
		host.LastChecked = time.Now()

		if err != nil {
			host.IsUp = false
		} else {
			defer conn.Close()
			host.IsUp = true
		}
	}

	host.AddMetric(host.ResponseTime, host.IsUp)
	return host
}

func hasHTTPPrefix(s string) bool {
	return len(s) >= 7 && (s[:7] == "http://" || (len(s) >= 8 && s[:8] == "https://"))
}

func main() {
	hostsFile := "hosts.json"
	metricsFile := "metrics.json"
	store := NewStatusStore()

	if err := store.LoadFromFile(hostsFile); err != nil {
		log.Printf("Error loading hosts from %s: %v", hostsFile, err)
	}

	nextRefreshTime := time.Now()
	refreshInterval := 2 * time.Minute

	go func() {
		for {
			hosts := store.GetAllHosts()
			for _, host := range hosts {
				updatedHost := CheckHostStatus(host)
				store.UpdateHost(updatedHost)
			}

			if err := store.SaveToFile(hostsFile); err != nil {
				log.Printf("Error saving hosts to %s: %v", hostsFile, err)
			}

			if err := store.SaveMetricsToFile(metricsFile); err != nil {
				log.Printf("Error saving metrics to %s: %v", metricsFile, err)
			}

			nextRefreshTime = time.Now().Add(refreshInterval)
			time.Sleep(refreshInterval)
		}
	}()

	http.HandleFunc("/api/hosts", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		if r.Method == http.MethodGet {

			secondsUntilRefresh := int(time.Until(nextRefreshTime).Seconds())
			if secondsUntilRefresh < 0 {
				secondsUntilRefresh = 0
			}

			type Response struct {
				Hosts              []Host `json:"hosts"`
				NextRefreshSeconds int    `json:"next_refresh_in_seconds"`
				MetricsAge         int    `json:"metrics_retention_seconds"`
			}

			response := Response{
				Hosts:              store.GetAllHosts(),
				NextRefreshSeconds: secondsUntilRefresh,
				MetricsAge:         7200,
			}

			json.NewEncoder(w).Encode(response)
			return
		}

		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	})

	http.HandleFunc("/api/hosts/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		id := r.URL.Path[len("/api/hosts/"):]

		if r.Method == http.MethodGet {
			host, exists := store.GetHost(id)
			if !exists {
				http.Error(w, "Host not found", http.StatusNotFound)
				return
			}

			json.NewEncoder(w).Encode(host)
			return
		}

		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	})

	http.HandleFunc("/api/check", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		if r.Method == http.MethodPost {
			hosts := store.GetAllHosts()
			for _, host := range hosts {
				updatedHost := CheckHostStatus(host)
				store.UpdateHost(updatedHost)
			}

			if err := store.SaveToFile(hostsFile); err != nil {
				log.Printf("Error saving hosts to %s: %v", hostsFile, err)
			}

			w.WriteHeader(http.StatusOK)
			json.NewEncoder(w).Encode(store.GetAllHosts())
			return
		}

		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	})

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			http.NotFound(w, r)
			return
		}

		htmlFile := "serve.html"
		content, err := ioutil.ReadFile(htmlFile)
		if err != nil {
			log.Printf("Error reading serve.html: %v", err)
			http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "text/html")
		w.Write(content)
	})

	fmt.Println("Status API server starting on :8080...")
	http.ListenAndServe(":8080", nil)
}
